[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "",
    "section": "",
    "text": "Just like the music is written and understood by musicians in a coded language, what is the language with which nature speaks. Physicists claim - nature communicates in a language of elegant matematical equations. Why would nature chose to speak in such a difficult language of mathematics? Or, is it that nature speaks in many different languages, it’s only upto the observer to understand it. These are the philosophical questions I love to ruminate about.\nIn short, human civilization is a story of journey into the unknown and this journey into the unknown has sometimes been ispired by curiosity and at times by necessity. I also wonder why things are the way they are. On some dark night, alone in the wilderness, looking up in the sky, do you ever wonder where did this all come from. In the vastness of the universe, I feel helpless, insignificant and hopeless. However, the joy I find in being able to understand miniscule of the vastness of the universe is inspiring."
  },
  {
    "objectID": "computation/FourierAnalysis.html",
    "href": "computation/FourierAnalysis.html",
    "title": "Signal processing has its root in Fourier Analysis",
    "section": "",
    "text": "We use Maclaurin’s series expansion to approximate a function which is continuous and for which the higher order derivative exists. Remember, Maclaurin series is a Taylor’s series of a function expanded at reference point 0. For instance, Maclaurin’s expansion of \\(sin(x)\\) is given by:\n\\[sin(x) = x - \\frac{x^3}{6} + \\frac{x^5}{120}\\]\nThis comes from the Maclaurin’s series expansion of \\(sin(x)\\).\nMaclaurin’s series expansion is given by:\n\\[ f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{n}(0)}{n!}x^n  \\]\nHigher order derivatives for function \\(sin(x)\\) exists and is a continuous function so it can be approximated to the desired accuracy(provided that required computational resource exists) using Maclaurin’s series expansion. But how would we model a discontinuous function such as one defined below:\n\\[f(x) = x\\] in the range -2&lt;x&lt;2. Grpahically this function looks as shown below.\n\n\n\nFunction Graph\n\n\nWe can model such discontinuous function using Fourier series given by:\n\\[ f(x) = \\frac{a_{0}}{2} + \\sum_{n=1}^{\\infty}\\left[ a_{n}Cos\\left(\\frac{2n\\pi x}{L}\\right) + b_{n}Sin\\left(\\frac{2n\\pi x}{L}\\right) \\right]  \\]\nRefer this source for theoretical aspect of fourier seiries.\nGiven function in the example is an odd function so the function can only be modelled with coefficient \\(b_{n}\\) as all the \\(a_{n}, a_{0}\\) coefficient will be zero for odd function. Using Fourier integral for fourier coefficient \\(b_{n}\\) I got the value\n\\[ b_{n} =  \\frac{4 (-1)^{n+1}}{n \\pi}  \\]\nHence, given function will be modelled by the fourier series expression below.\n\\[ f(x) = \\sum_{n=1}^{\\infty} \\left[ \\frac{4 (-1)^{n+1}}{n \\pi} Sin\\left(\\frac{n \\pi x}{2}\\right) \\right] \\]\nUsing this result we can visualize how given function will be modelled if we take fourier series sum for various number of terms in above series. Below is a graph there shows how the actual function(in blue) will be modelled by fourier series when we take a sum of 1, 5, 25 and 125 terms. As we can see as we approximate with larger and larger number of terms in the series given function is more and more accurately represented.\nThis is the power of fourier series that it can be used to model discontinuous function. Discrete fourier transform and fast fourier transform are the successive results that arises on the foundationi of fourier analysis. All modern electronic devices such as cell phones, radio communication, etc use this idea of fast fourier transform in signal processing. Once again, mathematics lies at the base of the beauty of everything.\n\n\n\nFourier Graph"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "",
    "section": "",
    "text": "In case you are interested here is my CV."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anoj Khadka",
    "section": "",
    "text": "Hi, I am Anoj and have special interest in physics, mathematics and computation. I am a graduate student in physics department here at West Virginia University. Broadly speaking, I am working on pulsar astronomy. Currently, I am focused on two different research projects. One of them involves searching for pulsars for which I use open source softwares to explore data from various radio telescopes. Parallelly, I also work on new algorithm developments for various aspects of pulsar astronomy. Besides academia, I love to walk through the wilderness and explore nature. Don’t ask me if I am interested in music, it is in my blood. In this personal website of mine I will write on topics of my above mentioned interests, both academic and non-academic. In case you want to contact me, my email is khadkaanoj@gmail.com."
  },
  {
    "objectID": "computation/MandelbrotAndChaos.html",
    "href": "computation/MandelbrotAndChaos.html",
    "title": "",
    "section": "",
    "text": "Mandelbrot Set\nMandelbrot set is a set of complex numbers that obey certain mathematical rule. First studied by Robert Brooks and Peter Matelski and visualized by Benoit Mandelbrot while woking in IBM, it represents the complexity and has many applications in the study of chaos theory, number theory, fractal geometry, etc. Mathematically, it is defined by a simple function:\n\\[x_{n} = x_{0}^2 + c  \\]\nwhere ‘c’ is a set of complex numbers and ‘\\(x_{0}\\)’ is 0. This set of such complex numbers for which the functional value defined above does not diverge even at infinity, comprises a Mandelbrot set. Starting with \\(x_{0} = 0\\) and any complex number ’c` we keep summing up the numbers iteratively as:\n\\[ x_{1} = 0 + c \\] \\[ x_{2} = x_{1}^2 + c \\] \\[ x_{3} = x_{2}^2 + c \\] \\[..........\\] \\[..........\\] \\[..........\\]\n\\[ x_{n} = x_{n-1}^2 + c \\]\nEven when we take this sum to infinity, if the sum does not diverge from the complex number ‘c’, the number belongs to a Mandelbrot set. Here the \\(x_{0}\\) is called a seed and the summation orbit of the seed. So, Mandelbrot set is a set of these complex numbers for which the orbit of the seed 0 does not diverge to infinity.\nWhen we make a plot of Mandelbrot set, it gives rise to form a beautiful looking design pattern as shown below. Generally, we use complex nubers \\(z = x + iy\\) within x and y values ranging in between (-2,2). It has been derived mathematically that this series will converge below a radius of 2 when seed is 0 for given set of complex numbers in above range of x and y values. So, we use this radius as a braking/limiting condition for our iteration loop.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef mandelbrot_set(lower_limit, upper_limit, total_number, max_iteration):\n    \n    \"\"\" This function will first create a 2-D array of zeros. We then create complex numbers within a complex plane with x and y \n    values ranging between (-1.5, 1.5). These complex numbers are each tested to see if iterative sum exceeds the radius of \n    convergence value 2 when seed of 0 is taken. If value diverge we change that complex number in the complex plane to 1.\n    Finally a plot of these 2-D matrix set is created to visualize the mandelbrot set. One can tweak the seed value and range of\n    complex numbers taken just to see how the graph changes.\"\"\"\n    \n    blank_set = np.zeros((total_number,total_number))\n    number_sample = np.linspace(lower_limit, upper_limit, total_number)\n    for n1 in range(total_number):\n        x = number_sample[n1]\n        for n2 in range(total_number):\n            y = number_sample[n2]\n            c = complex(x,y)                              # Complex number to test\n            z = 0                                         # Seed number\n            for k in range(max_iteration):\n                z = z**2 + c\n                if abs(z) &gt; 2:\n                    blank_set[n1,n2] = 1\n                    break\n    return blank_set\n\n\ndef mandelbrot_graph(mandel_set):\n    plt.figure(figsize=(12,12))\n    plt.imshow(mandel_set, extent=(-2.0, 2.0, -2.0, 2.0))\n\ndef main():\n    result1 = mandelbrot_set(-1.5, 1.5,1024,300)\n    result2 = mandelbrot_graph(result1)\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\n\n\nThis is based on the reference source linked below.\nhttps://math.bu.edu/DYSYS/FRACGEOM/FRACGEOM.html"
  },
  {
    "objectID": "computation/DiscreteFourierTransform_DFT.html",
    "href": "computation/DiscreteFourierTransform_DFT.html",
    "title": "Before we start ",
    "section": "",
    "text": "Fast fourier transform(FFT) is hailed as a one of the most important algorithm of the twenty first century as it lies at the heart of the most of the signal processing tasks performed in electronics. Discrete fourier tansform is a precursor of FFT but less efficient. Even for DFTs, there are many efficient version of algorithm online and inbuilt in many softwares(eg, scipy, matlab, mathematica, etc). Here we just try to dig into the fundamental mathematical result upon which DFT algorithm is based upon and show how it works at a very basic level. There are conditions when DFT algorithm fails but we won’t be discussing them here. This tutorial is focused only on mathematical overview and how the algorithm is built based upon this mathematical framework, including examples which will demonstrate how DFT algorithm works practically. For readers interested to explore further, there are tons of resources online and many signal processing books also explain them in good details.\n\nSection 1: Brief mathematical overview of discrete fourier transform(DFT)\nDiscrete fourier transform is a discretized form of Fourier transform which itself originates from Fourier series analysis. In fourier series analysis any discontinuous function satisfying Dirichlet’s conditions can be approximated by complex fourier series as:\n\\[ \\Large f(t) = \\sum_{n=-\\infty}^{\\infty} C_{n}  exp(i \\omega_{n}t) \\tag{1} \\]\nwhere Fourier coefficient \\(C_{n}\\) and frequency \\(\\omega_{N}\\) are given by:\n\\[\\Large C_{n} = \\frac{1}{T} \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(u) exp\\left(-i \\omega_{n} u\\right) du\\] \\[\\Large \\omega_{n} = \\frac{2\\pi n}{T} \\]\nFor a scenario where \\(T\\rightarrow \\infty\\), frequency spectrum \\(\\omega_{n}\\) becomes continuous and substituting fourier coefficient in above fourier series we get fourier integral\n\\[\\Large F(\\omega) = C \\int_{-\\infty}^{\\infty} f(t) exp\\left(-i \\omega_{n} t\\right) dt  \\tag{2}\\]\nwhere coefficient C will depend on the timeperiod chosen. This integral represents Fourier transfrom of a function \\(f(t)\\). This is where all the signal processing journey begins from. We have some timeseries function \\(f(t)\\) and want to analyze its phase and frequency then we use Fourier transfrom. As you can see, this integral takes function of time - f(t) and gives function in frequency \\(F(\\omega)\\). So, it helps us to extract frequency domain information by giving time domain input.\nTime signal as input \\(\\Rightarrow\\) Fourier Transform \\(\\Rightarrow\\) Phase & frequency information as output of given signal\nThis power of fourier transform to feed time signal as input, which most of the signal in electronics world are, and get information about its phase and frequency makes it the single most important algorithm of the modern world.\nWhere the heck does DFT come from ?\nFourirer transfrom equation is for a case where the function is continuous and extends for huge amount of time(almost infinite). However, if we have a function(e.g. electrical signals) that appears for a very small amount of time and can be sampled for ‘N’ number of times we can use a discrete form of the above fourier integral and this discretized version of fourier transfrom for function measured at small time interval is what DFT is. So, for a function/signal measured at certain interval of time(say T) and recorded N number of times we could write above fourier integral as:\n\\[\\Large F(\\omega) = f(0) e^{-i \\omega 0} + f(1) e^{-i \\omega 1T} + f(2) e^{-i \\omega 2T} + .......+ f(N-1) e^{-i \\omega (N-1)T} \\] \\[\\Large F(\\omega) = \\sum_{k=0}^{N-1} f(k)e^{-i \\omega kT} \\tag{3}\\]\nYou can understand this as we are measuring some electronic signal such as cell phone signal at time stamp of t = 0, t = 1,…. t= N-1 secs at discrete timeperiods 0T, 1T, 2T,…..,(N-1)T.\nIf the function(signal) we are measuring is periodic and comes at different frequencies we are measuring the function at different frequencies. For a signal with timeperiod T and measured N number of times the highest frequency with which we are measuring the function(signal) is \\(\\frac{1}{NT}\\). Remember \\(freq = \\frac{1}{time}\\). This is also called the fundamental frequency. So, we will have various frequency of measurements if the same signal is coming at different frequencies. \\[\\Large \\omega_{n} = 0,   \\left(\\frac{2\\pi}{NT}\\right)1,   \\left(\\frac{2\\pi}{NT}\\right)2,    \\left(\\frac{2\\pi}{NT}\\right)3,.........,\\left(\\frac{2\\pi}{NT}\\right)(N-1) \\;\\;\\;\\;\\;\\;\\; where\\;\\; n = 0, 1, ....., (N-1)\\]\nHere \\(\\large \\omega\\) represents angular frequency given by general expression \\(\\large \\omega = \\frac{2\\pi}{T}\\)\nUsing this in equation 3 and substituting ‘\\(\\large \\omega_{n}\\)’ we get a general expression for discrete fourier transfrom given by:\n\\[\\Large F(n) = \\sum_{k=0}^{N-1}  f(k)e^{\\huge(\\frac{-i 2\\pi n kT}{NT}\\huge)} \\;\\;\\;\\;\\;\\;\\; where\\;\\; n = 0, 1, 2,.....N-1 \\] (Cancelling T from numerator and denominator)\nThis expression can be written in more popular form of DFT expression below\n\\[\\Large F(n) = \\sum_{k=0}^{N-1} f(k)e^{\\huge(\\frac{-i 2\\pi nk}{N}\\huge)} ; \\;\\;\\;\\;\\;\\;\\;\\;\\; n = 0, 1, 2,.....N-1\\tag{4} \\]\nLet us use \\(e^{\\huge( \\frac{-i 2 \\pi}{N}\\huge)} = W\\), for convenience. Above expression simplifies to the form\n\\[\\Large F(n) =  \\sum_{k=0}^{N-1}   \\Large[f(k){W^{n}}\\Large]^{k}   \\tag{5}\\]\nFor n = 0, \\(W^{0} = 1\\) and above series expansion becomes\n\\[\\Large F(0) = \\sum_{k=0}^{N-1} f(k) =  f(0) + f(1) + f(2) + f(3) +  .....+ f(N-1)\\]\nFor n = 1, \\(W^{n} = W\\),\n\\[\\Large F(1) = \\sum_{k=0}^{N-1} f(k)W^{k} =  f(0) + f(1)W + f(2)W^{2} + f(3)W^{4}.....+ f(N-1)W^{N-1}\\]\nFor n = 2, \\(W^{n} = W^{2}\\),\n\\[\\Large F(2) = \\sum_{k=0}^{N-1} f(k)\\Big(W^{2}\\Big)^{k} =  f(0) + f(1)W^{2} + f(2)W^{4} + f(3)W^{6}.....+ f(N-1)W^{2N-2}\\] . . . .\nContinuing, for n = N-1, i.e. \\(W^{n} = W^{N-1}\\)\n\\[\\Large F(N - 1) = \\sum_{k=0}^{N-1} f(k)\\Big(W^{N-1}\\Big)^{k} =  f(0) + f(1)W^{N-1} + f(2)W^{2N-2} + f(3)W^{3N - 3}.....+ f(N-1)\\Big(W^{N-1}\\Big)^{N-1}\\]\nRemember, these terms F(0), F(1), F(2),……., F(N-1) will represent amplitudes when normalized by dividing by the total number of terms ‘N’. And in our signal analysis whichever amplitudes are greatest will be the dominant term giving us the dominant frequencies(\\(\\omega_{n}\\)) given by ‘n’ value. We can write above DFT series expansion in matrix form as:\n$$\n\\[\\begin{bmatrix} F(0)\\\\\nF(1)\\\\\nF(2)\\\\\n.\\\\\n.\\\\\n.\\\\\nF(N-1)\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}\n1 & 1  & 1  & 1  & .......... 1\\\\\n1 & W & W^{2}&  w^{3} & .....W^{N-1}\\\\\n1 & W^{2}&  W^{4}&  W^{6}& .....W^{2N - 2}\\\\\n& .&. & .& .\\\\\n& .&. &. & .\\\\\n& .&. &. & .\\\\\n1 & W^{N-1}&  W^{2N - 2}&  W^{3N - 3}& .....\\Big(W^{N - 1}\\Big)^{N-1}\\\\\\end{bmatrix}\\]\n\\[\\begin{bmatrix}\nf(0)\\\\\nf(1)\\\\\nf(2)\\\\\n.\\\\\n.\\\\\n.\\\\\nf(N-1)\n\\end{bmatrix}\n\\tag{6}\\]\n\\[\n\\] F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; W ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;f$$\nIf we observe above matrix(W) in the middle it is a symmetric matrix. Due to its symmetric nature when we analyze a signal, DFT algorithm gives symmetrical spectrum of frequencies so we can only take half of the spectrum as the other half is simply a complex conjugate values or a mirror image of the first half. This nature of symmetry allows DFT algorithm to be optimized and fast fourier transform(FFT) algorithm exploits this property to optimize the algorithm. However, we won’t discuss FFT here. Now, lets put all this math into work and see with some examples how DFT can decode any function/signal into frequencies of its constituent component signals.\n\n\nSection 2: Demonstration of DFT Algorithm based on above theory\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sympy import *\nimport math\n\nLet’s take a test function and see above mathematical theory in action. Any wave/signal can, in general, be represented by a function below.\n\\[ \\mathbf{f(t) = A sin(\\omega t) \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; where \\;\\;         \\omega = 2\\pi f}\\]\nwhere ‘A’ represents amplitude, ‘\\(\\omega\\)’ represents angular frequency. ‘f’ is just frequency. The fact that we use angular frequency comes from the mathematics because it is convenient to use polar co-ordinate system to represent complex numbers and DFT series has complex term \\(e^{i\\omega t}\\) in it. Don’t get confused one can be converted to other using above relation.\nTake a test function \\[ \\mathbf{f(x) = 5sin(2\\pi1t) + 0.5sin(2\\pi 2t) + 3sin(2\\pi3t)}\\]\nLets us suppose we have some kind of electrical signal represented by above function which graphically looks as shown below.\n\n# Making a graph of above function\n\nt = np.arange(100);\nf = np.arange(100);\nN = len(f)                       # Total number of samples/data points.\n\n# If we are only measuring at one single instant we would not include 'N' in equation below. But when we are measing signals we \n# try to sample it huge number of times so that we can get as much information about the incoming signal. \n\nf_t = 5*np.sin(2*np.pi*(1/N)*t) + 0.5*np.sin(2*np.pi*(2/N)*t) + 3*np.sin(2*np.pi*(3/N)*t)\nfunc_t = Matrix(f_t)\nplt.plot(t,f_t)\nplt.xlabel('t')\nplt.ylabel('f(t)')\nplt.title('Test function $\\mathbf{f(x) = 5sin(2\\pi1t) + 0.5sin(2\\pi2t) + 3sin(2\\pi3t)}$')\nplt.show()\n\n\n\n\n\n\n\n\nFor the sake of convenience and visualization I will take the same function above and do the calculation of algorithm matrices above for N = 7 points instead of N = 100(or any other numbers) points because its not convenient and easy to visualize a matrix of shape ‘100 \\(\\times\\) 100’ inside the cell of this jupyter notebook. You can consider changing value ‘7’ in ‘time_t’ and ‘freq_f’ variables below to any other numbers(eg, 50, 100, etc) and see if the algorithm can still extract the frequency and amplitude of this function/signal. Only inconvenience would be that such a huge size of matrix is difficult to fit in the cell. Or, just comment the line which displays the matrix and rest should be fine.\n\n# Plotting same function but with less number of points or time stamps taken. The reason graph will not look smooth is beacause \n# now I have plotted it with very few number of points. But the nature can still be seen to convince us its same function.\n\ntime_t = np.arange(7);\nfreq_f = np.arange(7);\nN = len(freq_f)                       # Total number of samples/data points.\nfunction__f = 5*np.sin(2*np.pi*(1/N)*time_t) + 0.5*np.sin(2*np.pi*(2/N)*time_t) + 3*np.sin(2*np.pi*(3/N)*time_t)\nfunc_t = Matrix(function__f)          # Keeping the functional values in matrix form.\nplt.plot(time_t,function__f)\nplt.xlabel('t')\nplt.ylabel('f(t)')\nplt.title('Test function $\\mathbf{f(x) = 5sin(2\\pi1t) + 0.5sin(2\\pi2t) + 3sin(2\\pi3t)}$')\nplt.show()\n\n\n\n\n\n\n\n\nIn the DFT series equation(eqn 4) above we have product of ‘n’ and ‘k’ in the exponential term. ‘t_matrix’ and ‘f_matrix’ variables represent ‘k’ and ‘n’ respectively. Then we can calculate \\[ e^{\\huge(\\frac{-i 2\\pi nk}{N} \\huge)} \\]\nand thiw will give us the matrix(W) in eqn 6. It is also called DFT kernel function.\n\nn_times_k = freq_f*time_t.reshape(len(time_t),1) \nexp_func = np.round(np.exp(-1j*2*np.pi*(1/N)*n_times_k), 3)   \n\n# This is in essence calculating F(0), F(1), etc, represented by the matrix on the left hand side in eqn 6, by multiplying \n# DFT kernel array 'exp_func' and functional values array 'function__f'.\n\ndft_func = np.dot(exp_func, function__f)                  \n\n\n# Let us visualize our DFT kernel matrix below. Notice these are complex numbers. Notice how first row and first column are \n# just 1 as we see in the discussion of DFT algorithm above. All other numbers are in the form a + ib where a is real part\n# and b is imaginary part. \n\nDFT_kernel = Matrix(exp_func)\nprint('\\n DFT kernel matrix times function matrix. \\n ')\nDFT_kernel\n\n\n DFT kernel matrix times function matrix. \n \n\n\n\\(\\displaystyle \\left[\\begin{matrix}1.0 & 1.0 & 1.0 & 1.0 & 1.0 & 1.0 & 1.0\\\\1.0 & 0.623 - 0.782 i & -0.223 - 0.975 i & -0.901 - 0.434 i & -0.901 + 0.434 i & -0.223 + 0.975 i & 0.623 + 0.782 i\\\\1.0 & -0.223 - 0.975 i & -0.901 + 0.434 i & 0.623 + 0.782 i & 0.623 - 0.782 i & -0.901 - 0.434 i & -0.223 + 0.975 i\\\\1.0 & -0.901 - 0.434 i & 0.623 + 0.782 i & -0.223 - 0.975 i & -0.223 + 0.975 i & 0.623 - 0.782 i & -0.901 + 0.434 i\\\\1.0 & -0.901 + 0.434 i & 0.623 - 0.782 i & -0.223 + 0.975 i & -0.223 - 0.975 i & 0.623 + 0.782 i & -0.901 - 0.434 i\\\\1.0 & -0.223 + 0.975 i & -0.901 - 0.434 i & 0.623 - 0.782 i & 0.623 + 0.782 i & -0.901 + 0.434 i & -0.223 - 0.975 i\\\\1.0 & 0.623 + 0.782 i & -0.223 + 0.975 i & -0.901 + 0.434 i & -0.901 - 0.434 i & -0.223 - 0.975 i & 0.623 - 0.782 i\\end{matrix}\\right]\\)\n\n\n\n# Similarly, 'f' matrix of functional values  is\n\nprint('\\n Matrix representing value of given function at each instant of time \\n')\nfunc_t\n\n\n Matrix representing value of given function at each instant of time \n\n\n\n\\(\\displaystyle \\left[\\begin{matrix}0\\\\5.69827258578374\\\\2.31220324394625\\\\4.70328669089925\\\\-4.70328669089925\\\\-2.31220324394625\\\\-5.69827258578373\\end{matrix}\\right]\\)\n\n\n\n# Now multiplying these two matrices should give us another matrix 'F'. Notice how these values are complex \n# numbers as expected.\n\nproduct_matrix = Matrix(dft_func)\nprint(\"\\n Product of kernel matrix 'W' and function matrix 'f' giving us 'F' matrix. \\n\")\nproduct_matrix\n\n\n Product of kernel matrix 'W' and function matrix 'f' giving us 'F' matrix. \n\n\n\n\\(\\displaystyle \\left[\\begin{matrix}1.77635683940025 \\cdot 10^{-15}\\\\- 17.5033474975615 i\\\\1.77635683940025 \\cdot 10^{-15} - 1.74869874196651 i\\\\-1.77635683940025 \\cdot 10^{-15} - 10.5012237781819 i\\\\-1.77635683940025 \\cdot 10^{-15} + 10.5012237781819 i\\\\1.77635683940025 \\cdot 10^{-15} + 1.74869874196651 i\\\\-4.44089209850063 \\cdot 10^{-16} + 17.5033474975615 i\\end{matrix}\\right]\\)\n\n\nAll values we get for F(0), F(1), F(2), etc are complex numbers in the form a + ib. Amplitude is mathematically defined as:\n\\[ amp = \\frac{\\sqrt{Re(F(k))^{2} + Im(F(k))^{2} }}{N} \\]\nFor a complex number \\(z = a + ib\\), \\(abs()\\) function in python calculates:\n\\[ abs(z) =  \\sqrt{a^{2} + b^{2}}\\]\n\n# Calculating amplitudes from F(0), F(1), etc. You might be wondering why we divide by N/2 instead of N. Remember the \n# kernel matrix is symmetric. Due to the symmetric nature effective number is just N/2. Also notice that the matrix \n# elements are identical if we divide the whole matrix into half. For instance 2nd element is identical to 7th element, 3rd to \n# 6th and so on. \n\namp = abs(dft_func)/(N/2)  \namp_matrix = Matrix(amp)\nprint('\\n Calculated amplitudes of the given signal for several frequencies \\n')\namp_matrix\n\n\n Calculated amplitudes of the given signal for several frequencies \n\n\n\n\\(\\displaystyle \\left[\\begin{matrix}5.07530525542929 \\cdot 10^{-16}\\\\5.00095642787471\\\\0.499628211990433\\\\3.00034965090911\\\\3.00034965090911\\\\0.499628211990433\\\\5.00095642787471\\end{matrix}\\right]\\)\n\n\n\n# Making a stem plot of amplitudes vs frequencies. \nplt.stem(time_t, amp)\nplt.xlim(0,len(time_t))\nplt.xlabel('Frequency', fontweight = 'bold', fontsize = 14)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Amplitude vs frequency plot obtained from DFT algorithm', fontsize = 14)\nplt.show()\n\n\n\n\n\n\n\n\nYou can see finally we recovered both amplitude and frequency by using the DFT algorithm. Also, notice the spectrum is identical on both side if divided from mid-point. This is due to the symmetric nature of the DFT kernel matrix. So, in practice we can only use half of the spectrum plot and ignore other half. These amplitudes and frequencies are exactly the same as defined in the function. Input function had frequencies 1, 2 and 3 and amplitudes 5, 0.5 and 3.\n\n\nSection 3:  Decomposing original function/signal into its constituents components\nBelow we can graphically see original function/signal(red) and component functions/signals(blue). The component signals are plotted using the frequency and amplitude extracted from the DFT algorithm. So, original input signal is just a superposition of three component signals with given frequencies and amplitude. This clearly shows us how we can breakdown given function/signal into its component signals.\n\ntimestamps = np.arange(100);\ntotal_N = len(timestamps)\noriginal_signal = 5*np.sin(2*np.pi*(1/total_N)*timestamps) + 0.5*np.sin(2*np.pi*(2/total_N)*timestamps) + 3*np.sin(2*np.pi*(3/total_N)*timestamps)\nsignal_one = 5*np.sin(2*np.pi*(1/total_N)*timestamps)\nsignal_two = 0.5*np.sin(2*np.pi*(2/total_N)*timestamps)\nsignal_three = 3*np.sin(2*np.pi*(3/total_N)*timestamps)\n\nplt.figure(figsize = (10, 20))\nplt.subplot(411)\nplt.plot(timestamps, original_signal, color = 'red')\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Original input signal')\nplt.subplot(412)\nplt.plot(timestamps, signal_one)\nplt.ylabel('Amplitude' , fontweight = 'bold', fontsize = 14)\nplt.title('First signal component')\nplt.subplot(413)\nplt.plot(timestamps, signal_two)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Second signal component')\nplt.subplot(414)\nplt.plot(timestamps, signal_three)\nplt.xlabel('Frequency', fontweight = 'bold', fontsize = 14)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Third Signal component')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nSection 4: Let’s play with one more example using larger sampling size\nIn this example we consider a function/signal represented by: \\[ \\mathbf{ f(t) = 5sin(2\\pi 1t) + sin(2\\pi6t) + 0.5sin(2\\pi12t)}\\]\nLets us see if we can still extract frequency and amplitude of the individual signal components of this input function/signal using the DFT algorithm we used above.\n\ndt = np.arange(100)\nno_of_freq = np.arange(100)\ntotal_no_sample = len(dt)\ninput_function = 5*np.sin(2*np.pi*(1/total_no_sample)*dt) + np.sin(2*np.pi*(6/total_no_sample)*dt) + 0.5*np.sin(2*np.pi*(12/total_no_sample)*dt)\nplt.figure(figsize = (8,6))\nplt.plot(dt,input_function, 'r')\nplt.xlabel('time', fontweight = 'bold', fontsize = 14)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Input signal', fontweight = 'bold', fontsize = 14)\nplt.show()\n\n\n\n\n\n\n\n\n\ndef DFT(f_of_x):\n\n    \"\"\"Function to calculate the discrete Fourier Transform of a 1D real-valued signal/function. We supply the functional values\n    and this will calculate the amplitudes for that functional values.\"\"\"\n    \n    signal_size = len(f_of_x)\n    n = np.arange(signal_size)\n    k = n.reshape((signal_size, 1))\n    kernel_W = np.exp(-2j*np.pi*k*n/signal_size)\n    F_matrix = np.dot(kernel_W, f_of_x)\n    amplitude_values = np.round(abs(F_matrix)/(signal_size/2), 3)\n    return amplitude_values\n\n\nY = DFT(input_function)   # Amplitudes calculated by the above DFT algorithmic function.\nX = dt                    # Same times stamples we have taken\n\n\n# Visualizing the extraction of frequency and amplitude of the given input signal.\n\nplt.figure(figsize = (12, 10))\nplt.subplot(211)\nplt.stem(X, Y, 'b', markerfmt = ' ', basefmt = '-b')\nplt.ylabel('Amplitude',  fontweight = 'bold', fontsize = 14)\nplt.title('Fig 1: Whole frequency spectrum with their respective amplitude', fontweight = 'bold', fontsize = 14)\nplt.subplot(212)\nplt.stem(X, Y, 'b', markerfmt = ' ', basefmt = '-b')\nplt.xlabel('Freq (Hz)' , fontweight = 'bold', fontsize = 14)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.grid(axis = 'y', which='both')\nplt.xlim(0,15)\nplt.title('Fig 2: Zooming into small section of the above spectrum', fontweight = 'bold', fontsize = 14)\nplt.show()\n    \n\n\n\n\n\n\n\n\n\nHurray! We got the expected amplitude(5,1,0.5) and frequency(1,6,12) of the component signals as seen in the second figure above.\nBelow we decompose input signal(red) into its component signals(blue). First plot in red is superposition of three succeeding plots in blue.\n\nfirst_component = 5*np.sin(2*np.pi*(1/total_no_sample)*dt)\nsecond_component = np.sin(2*np.pi*(6/total_no_sample)*dt)\nthird_component = 0.5*np.sin(2*np.pi*(12/total_no_sample)*dt)\n\nplt.figure(figsize = (10, 20))\nplt.subplot(411)\nplt.plot(dt, input_function, color = 'red')\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Original input signal')\nplt.subplot(412)\nplt.plot(dt, first_component)\nplt.ylabel('Amplitude' , fontweight = 'bold', fontsize = 14)\nplt.title('First signal component')\nplt.subplot(413)\nplt.plot(dt, second_component)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Second signal component')\nplt.subplot(414)\nplt.plot(dt, third_component)\nplt.xlabel('Frequency', fontweight = 'bold', fontsize = 14)\nplt.ylabel('Amplitude', fontweight = 'bold', fontsize = 14)\nplt.title('Third Signal component')\nplt.show()\n\n\n\n\n\n\n\n\nReferences: Following sources were consulted during the preparation of this lesson.\n\nhttps://www.robots.ox.ac.uk/~sjrob/Teaching/SP/l7.pdf\nhttps://pythonnumericalmethods.studentorg.berkeley.edu/notebooks/Index.html\n“Mathematical Methods for Physics and Engineering”, K. F. Riley, M. P. Hobson, S. J. Bence, University of Cambridge, 2006"
  }
]